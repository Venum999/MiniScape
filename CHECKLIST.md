# MiniScape Implementation Checklist

## Project Setup and Initialization  
- [x] 1. **Set up Next.js TypeScript project** – Initialize a new Next.js app (using `create-next-app` or manually). Ensure TypeScript is configured. Verify the development server runs. Create a clean repository structure.  
- [x] 2. **Install Dependencies** – Add required libraries: Three.js (`npm install three`), Socket.IO client and server (`npm install socket.io socket.io-client`) or if using native WebSocket, none needed for client as browser has it (and `ws` for server). Also add any helper libraries if needed (possibly none). Confirm `package.json` has all: react, react-dom (Next includes them), three, socket.io, etc.  
- [x] 3. **Basic Next.js page for game** – Create a main page (e.g., `pages/index.tsx`) that will host the game. This page will eventually contain the Three.js canvas and React UI components. For now, put a placeholder "Game is loading…" text to verify routing works.  
- [x] 4. **Project structure** – Set up a logical structure: maybe a folder for components (React UI components like ChatPanel, InventoryPanel), a folder for game logic or Three.js related code (maybe `game/` containing modules for world, player, etc.), and possibly a folder for server (though if using Next API, that goes under `pages/api`). Create stub files or at least plan these out.

## Three.js Rendering Engine Setup  
- [x] 5. **Create Three.js scene canvas** – Implement a React component that initializes a Three.js scene, camera, and renderer. This could be done in `pages/index.tsx` or a dedicated `<GameCanvas>` component. Use a `useEffect` hook to set up the scene after the component mounts. Basic steps: create a `THREE.Scene`, a `THREE.PerspectiveCamera` (e.g. fov 75, aspect from window size, near 0.1, far 1000), and a `THREE.WebGLRenderer` attached to a canvas. Append the canvas to the DOM or use a `ref` on a canvas element in JSX. Start an animation loop with `requestAnimationFrame` to render the scene each frame. Verify that you see a blank canvas (black screen by default) covering the page.  
- [x] 6. **Add simple environment** – In the Three.js scene, add a ground plane to represent terrain. For example, create a large `PlaneGeometry` with a grass-green material. Orient it flat (rotate X by -π/2 if needed so it lies horizontally). Add some basic ambient light (`THREE.AmbientLight`) and maybe a directional light (to have some shading). Also, set the camera position somewhere above the ground looking down (e.g., camera at (0, 50, 50) looking at (0,0,0)). This establishes the world space. Render and ensure the ground is visible (you might need to set `renderer.setClearColor` to sky blue to simulate sky).  
- [x] 7. **Player avatar placeholder** – Create a simple placeholder for the player character in the scene. This could be a `THREE.Mesh` using a `BoxGeometry` or `SphereGeometry` with a distinct color (representing the player). Position it at the starting location (e.g., near (0,0,0) on the ground). For now, this is just a static mesh. In the future, we'll have one for each player, but start with one for the local player. Confirm it renders properly above the ground.  
- [x] 8. **Camera follow logic** – Implement camera movement to follow the player. For example, on each frame in the render loop, update the camera position to some offset behind/above the player's position. A simple method: camera.position.x = playerMesh.position.x, camera.position.z = playerMesh.position.z + some offset, camera.position.y = playerMesh.position.y + some height. Or keep camera looking at player while orbiting. For now, even a fixed-position camera that still shows the player is fine. This step ensures as the player moves (next steps) the camera will track them, keeping the player in view.  

## Player Movement Controls  
- [x] 9. **Input handling for movement** – Set up event listeners for keyboard input (WASD/arrow keys). In the React component or in a separate input module, add `keydown` and `keyup` event listeners. Track which keys are currently pressed (e.g., an object like `{ up: false, down: false, left: false, right: false }`). On each animation frame, if keys are pressed, adjust the player's mesh position accordingly. For example, if "W" or Up is pressed, increase playerMesh.position.z by +speed*delta or something (depending on coordinate system orientation—if camera is facing negative Z as forward, adjust accordingly). Do similar for S/D/A for backwards/right/left. Use a reasonable speed so the movement looks natural. Test that you can move the placeholder player around with the keyboard locally.  
- [x] 10. **Constrain movement area** – To simulate world boundaries and distinct zones, implement simple limits: e.g., if player tries to move beyond x = ±50 or z = ±50 (world edge), stop them. We can later refine to zone shapes, but a bounding box for the walkable area is fine initially. Also prevent movement through the ground (y axis not used). If inclined, also avoid going through objects by rudimentary checks (like if near a tree object, maybe stop, though this can be complex without physics—skip detailed collision for now or treat resource objects as non-solid).  

## Basic Multiplayer Networking  
- [x] 11. **Set up WebSocket server (Socket.IO)** – Implement a Next.js API route for the WebSocket server. Create a file like `pages/api/socket.ts`. In it, disable Next.js's default body parser (since we'll upgrade to WS). Initialize a Socket.IO server or a raw WebSocket server. (Using Socket.IO: you can check if an instance is already running to avoid duplication when Next hot-reloads; often a global instance or store it on `res.socket.server.io`). Set it up to listen for connections. When a new client connects, print a log to verify. This effectively creates the WebSocket endpoint (e.g. at `/api/socket`). Next, on the client side, connect to this socket.  
- [x] 12. **Connect client to WebSocket** – In the client code (maybe in a useEffect in the main game component), create a Socket.IO client connection to the server. The URL could be the same origin (e.g. just `io()` will auto-connect to the same host if Socket.IO script is loaded, or use `ws://localhost:3000/api/socket` if raw WS). Make sure to include the Socket.IO client script by importing from `socket.io-client`. Attempt to connect and listen for a "connect" event to confirm connection. Test by running the app, opening two browser windows, and see on server logs that two clients connected.  
- [x] 13. **Broadcast new player to others** – Implement on the server: when a client connects, assign them a unique ID (Socket.IO already has `socket.id`). You can also accept a username (perhaps the client emits a "join" message with their desired name). Keep a list (or object) of players on the server, storing at least their id, name, and initial position. Then notify existing players about the new player, and notify the new player about all existing players (so they can spawn them). Concretely: on new connection, server could broadcast a `playerJoined` event `{id, name, x, y, z}` to all *other* clients. And send the new client a `initPlayers` event containing an array of all current players (their ids, names, positions) so the client can populate the world with those. Implement the corresponding client-side handlers: on `playerJoined`, add a new avatar mesh to the scene for that player; on `initPlayers`, loop through the list and create avatars for each existing player. Use a different color or model for other players vs the local player to distinguish (maybe local is blue, others are red). At this point, if you open two clients, you should see two avatars in each (but not moving yet).  
- [x] 14. **Handle player disconnect** – In the server, listen for disconnect events (`socket.on('disconnect')`). When a player disconnects, remove them from the server's player list and broadcast a `playerLeft` (with that player's id) to all remaining clients. On the client, handle `playerLeft` by removing that player's mesh from the scene (and maybe removing them from any local state tracking). This prevents orphaned avatars if someone leaves.  

## Real-Time Movement Synchronization  
- [x] 15. **Send movement updates** – Now integrate movement with networking. On the client, whenever the player's position changes (from the movement controls), emit a `playerMove` event to the server. Throttle this to, say, 10 times per second to avoid overloading (e.g., use `setInterval` or track elapsed time in the render loop to send at fixed intervals). The message can contain the player's id (or rely on socket id on server side) and their new coordinates (and maybe direction if needed). On the server, listen for `playerMove` events from clients. When received, update that player's stored position in the server state, and broadcast a `playerMoved` event to all other clients with `{id, x, y, z}`. The server might choose to emit this only to others (not back to sender) to avoid echo (since the sender already moved locally). Alternatively, send to all including sender and the sender can ignore self updates.  
- [x] 16. **Receive and apply movement** – On each client, implement handler for `playerMoved` event. When a message arrives, find the corresponding player's mesh in the scene and update its position to the provided coords. This will make other players appear to move. Make sure to differentiate local vs remote: the local player's movements come from input, not network, so you might not receive a `playerMoved` for yourself if server didn't echo it. If you do receive your own (depending on implementation), you can ignore or use it for correction if needed. Now test with two browsers: moving in one should cause the avatar in the other to move. There might be slight latency but it should update smoothly if messages are frequent. Fine-tune as needed (possibly interpolate remote movements on client for smoothness, though with 20 players and moderate rate, it might be okay to jump them to position).  

## Chat Functionality  
- [x] 17. **Implement chat UI component** – Create a React component `<ChatPanel>` that renders a list of messages and an input box. Place it overlaying the game canvas (e.g. styled with CSS position absolute, bottom:0, left:0, width: maybe 30% of screen, height: 150px, overflow-y: scroll for messages). Style it simply. In React state, maintain an array of chat messages. Render each message as a `<div>` or `<p>`. Also create an input field; on submit (Enter key), call a handler to send the message. Integrate this component in the main page (e.g., include `<ChatPanel>` in the JSX so it shows up).  
- [x] 18. **Send and receive chat messages** – On the client, when the user submits chat text, emit a `chat` event via WebSocket with the message text. Also optimistically add it to your own chat panel (or you can wait to add on echo from server). On the server, listen for `chat` events. When received, prepend the sender's name (which you have from when they joined) and broadcast a `chat` (or `chatMessage`) event to all clients with `{name, text}`. On clients, listen for `chatMessage` and, when received, append it to the chat panel state (trigger re-render to show it). Ensure that the chat scrolls to the bottom on new message (you can do this via ref or by always rendering with newest at bottom and CSS auto-scroll). Test sending chat between two clients to ensure messages appear on both. Also handle clearing the input field after sending.  
- [x] 19. **Name input (optional if needed)** – If you want players to set a username, implement a simple prompt on join. E.g., show a modal or prompt at game start asking for a name, then include that in the connection (perhaps send a `join` event to server with the name). The server then uses that name for broadcasts. If not, just assign default names like "Player123". In RuneScape context, having a name is important for identity, so this is recommended even if trivial. Could also simply use the socket ID as name for now for testing.

## World and Resource Setup  
- [x] 20. **Create world objects (trees, rocks, etc.)** – In the Three.js scene, add some meshes to represent resources: e.g., a few **tree** meshes in Lumbridge area. This could be a simple cylinder + sphere combo (cylinder trunk, sphere foliage) or any quick way to show a tree. Similarly add **rock** meshes in another area for mining, and maybe a **water plane** for a fishing spot. These objects should have unique identifiers so we know which one is interacted with. You can create a simple class or data structure for ResourceNode with properties like id, type ("tree"/"rock"/"fish"), position (x, y, z). Hardcode a handful of nodes: e.g., 3 trees near Lumbridge spawn, 2-3 rocks in Barbarian Village, and a fishing spot near a water area. Also consider adding a few non-interactive props for atmosphere (like a building or two, or a campfire). This step is mainly to set the stage for interaction. Make sure these objects are added to an array so we can iterate for interaction (for raycasting on click). They should be added to the Three.js scene for rendering.  
- [x] 21. **Raycast for clicks on resources** – Implement click picking. In the Three.js canvas component, listen for `mousedown` or `click` events on the canvas. Use `THREE.Raycaster` to cast a ray from the camera through the mouse position into the scene. Check if it intersects any resource node mesh. If so, determine which resource was clicked (you can tag the mesh with a custom property linking to the resource id or have a mapping from mesh to resource data). If a tree or rock is clicked, initiate a gathering action. Possibly also check distance: ensure the player's avatar is close enough to that resource; if not, you might ignore or maybe move the player there first (auto-walk could be too much, so probably just require manual proximity). For now, assume the user will move near and click.  
- [x] 22. **Gather action request** – When a resource is clicked (and presumably in range), have the client emit a `gather` event to the server with the resource id (and type if needed, but id can imply type). Also, on the client, you can give immediate feedback: e.g., start a short timer or disable another click until server responds. Optionally, you could play an animation or change the resource appearance (e.g., tint the tree to indicate chopping). Those visual cues can be stretch enhancements; for now maybe just a console log "gathering...".  
- [x] 23. **Server-side gather logic** – On the server, handle the `gather` event. Upon receiving, find which resource it is. Check if it's available (you might not have a complex state for resources; maybe keep a simple set of currently unavailable ones if we wanted a respawn system). Likely we won't implement depletion, so it's always available. Then determine the item to give: if resource type is tree -> item = "Log", rock -> "Coal", fish spot -> "Fish". Create an entry for that item. Now update the player's inventory on server side: add the item to their list. (If server was not tracking inventory, we should; let's maintain a map of socket.id -> inventory array on server for authoritative tracking). Then emit an `inventoryUpdate` event to that specific client (so they know they got the item). Could also send a confirmation like `gatherSuccess` or simply piggyback on the inventory update. If we wanted others to see that action, we could broadcast something like "player X gathered resource Y", but that's not essential.  
- [x] 24. **Client inventory update handling** – When the client receives `inventoryUpdate` (likely containing the full updated inventory or just the new item), update the React state for the inventory list. This will cause the InventoryPanel to re-render and show the new item. For simplicity, send the full inventory each time (which is small). Alternatively, send just the item delta and let client add it – either works. Confirm that when you click a resource in one client, that client's inventory UI updates with the item. It should not yet reflect on other clients because each player's inventory is separate. (We're not showing other players' inventories anywhere except possibly if we chat about it or drop items.)  
- [x] 25. **Inventory panel and drop** – Create an `<InventoryPanel>` React component to display the inventory items (if not done earlier). It should iterate over inventory state and list items (with count if multiple). Next to each item, include a "Drop" button. Style the panel (e.g., top-right corner or a fixed small window). Ensure this panel updates on inventory state changes (React state handling).  

## Item Dropping and Picking  
- [x] 26. **Drop item action** – Implement the drop functionality. When the player clicks "Drop" on an item in the InventoryPanel, trigger a handler that emits a `dropItem` event to the server with the item type (and maybe an item id or index if needed to distinguish multiple of same type—could assume one at a time drop for simplicity). Also include the player's current position (the server could know it, but sending doesn't hurt) so the drop spawns there. On the client side, also remove that item from the inventory state immediately (or wait for server confirm). Probably best to wait for server to confirm, to keep authoritative state.  
- [x] 27. **Server drop handling** – On `dropItem` event (server), verify the player has that item in inventory (if tracking server-side). Remove one instance of it from their inventory list. Create a new world drop object with an id (generate a unique id or use a combination of item+timestamp), item type, and position (player's position from data or server's record). Add this to a server-side list of world items. Broadcast an `itemDropped` event to all clients with the drop's details: `{ dropId, itemType, x, y, z }`.  
- [x] 28. **Spawn dropped item in world** – On the client, listen for `itemDropped`. When received, create a visible object in the Three.js scene to represent the dropped item. It could be a small box or an icon sprite. Possibly use different colors or mini-models for different item types (e.g., brown box for log, gray for coal, blue for fish). Store these in a list of drop objects on the client, and perhaps also their id for reference. This way, everyone sees the item appear on ground. Also update the dropping player's inventory UI via the earlier `inventoryUpdate` (the server should also send an inventory update to the dropper after removing the item, so they see it gone from their list – do this if not already done in drop handling).  
- [x] 29. **Pick up item action** – Allow players to pick up dropped items. There are two ways: (a) clicking the item in the world (similar to resource click), or (b) auto-pickup by proximity. The easier to implement reliably is clicking (so we reuse raycasting). Implement raycast logic such that if the user clicks on a dropped item mesh, and is within a certain small radius of it (to prevent picking up across the map), then client emits a `pickup` event with the dropId. Alternatively or additionally, you can check distance on server for security. (Since we have positions, server can validate distance between player and item before giving item.)  
- [x] 30. **Server pickup handling** – On `pickup` event, check if that dropId exists in world items list. If yes, and if the player is near it (optional check: compute distance between player position and item position, allow if < some threshold, say 5 units), then remove the item from world list and add the item to that player's inventory. Broadcast an `itemRemoved` (with dropId) to all clients to despawn it, and send an `inventoryUpdate` to the picking player (with their new inventory). If the distance check fails or item doesn't exist (maybe already picked), you might send a failure (or just ignore).  
- [x] 31. **Client item removal** – On all clients, handle `itemRemoved` by finding the corresponding drop mesh in scene and removing it (and maybe disposing of it). On the picking client, also handle the `inventoryUpdate` that adds the item. Test this flow: one client drops an item, another client clicks it to pick up. The item should disappear from both clients' views and appear in the second client's inventory. The first client's inventory should have had it removed when dropped.  

## Additional Features and Polish  
- [x] 32. **Player name labels** – Add floating name labels above player avatars so players can identify each other. Implement by creating a HTML `<div>` or canvas 2D label for each player and update its screen position each frame according to the player's 3D position (using camera projection). There are libraries or Three.js `CSS2DRenderer` that can simplify this. Alternatively, use a simple sprite or text in Three.js (but 3D text might always face camera using `Sprite`). Given time, a quick method is to use an extra canvas renderer for text. This is a nice-to-have UI improvement so players see "Alice" over one avatar, etc.  
- [x] 33. **Zone indicators (optional)** – To make zones clear, you could add signage or change ground color between areas. For example, put a signpost reading "Wilderness" at the boundary and maybe draw a line. Or simply print the current zone name on screen (determine zone by player coords). This can be done client-side easily: each frame, check player position and set a text like "Location: Lumbridge" somewhere on UI.  
- [x] 34. **Sound effects (optional)** – If assets are available or can be quickly generated, add simple sounds for events: e.g., chopping sound when woodcutting, a mining cling, a splash for fishing, and maybe a notification sound for chat or when another player joins. Integrating sound involves preloading audio files and playing them with the Web Audio API or HTML5 Audio on certain events. This is lower priority but adds feedback.  
- [x] 35. **Testing and bug fixes** – Conduct multiplayer testing with multiple clients. Open several browser windows (or use an automated test if possible) to simulate ~3-5 players. Test scenarios: all players moving simultaneously (ensure positions update correctly and no one gets "stuck" or disappears), chat from various players (all receive and display), resource gathering (each player can independently gather and get items; two players gathering the same resource concurrently – with our infinite resource model this is fine, they both get items), item drop and pickup (make sure one player can't pick up twice or a nonexistent item, ensure inventory counts are correct). Fix any issues discovered (e.g., if movement messages overwhelm, consider lowering frequency or if chat input focusing is an issue, adjust event propagation, etc.). Ensure the game remains stable if someone disconnects and rejoins.  
- [ ] 36. **Performance tuning (if needed)** – If the frame rate is low, consider optimizations: e.g., limit the number of Three.js objects (merge meshes for static environment if too many, or reduce render distance if we had a huge world). If network usage is high, make messages smaller (e.g., send compressed or less frequent updates). Given the small scope, likely fine. Also handle any memory leaks (make sure on client, when removing objects or on unmount, you dispose of Three.js geometries, etc., to not accumulate).  
- [ ] 37. **Deploy or run production build (optional)** – If time remains, prepare the app for deployment. This could mean running `next build` and ensuring the production version works the same. If hosting, note that Next.js on platforms like Vercel might not support long-running WebSocket in API routes easily (serverless issue). We might need a custom Node server to run the Socket.IO. For the 35-hour project, running locally or on a VM is fine. Document that limitation if deploying.  

## Stretch Goal Implementation (Optional)  
- [ ] **(Optional) Implement PvP Combat in Wilderness** – Add a basic attack mechanism. For instance, allow clicking on another player's avatar in the Wilderness to initiate attack. Server handles an `attack` event: reduce the target's health (keep a health property in player state). Broadcast `playerHealth` update. If health ≤ 0, broadcast `playerDied`. On client, display health bars (could be a small red bar above players or in UI when targeted). If a player dies, perhaps remove them or respawn at Lumbridge (reset health, maybe drop their items as loot). This involves multiple steps: track health in server player objects, include health in `initPlayers` and updates, and create UI for it. Keep it very simple due to time.  
- [ ] **(Optional) Trading Interface** – Create a modal that opens when a player clicks "Trade" on another player (you'd need to add a UI element for that, perhaps by clicking their name label or a command). Implement a trade request/accept flow: one player sends `tradeRequest` to server with target id, server forwards to target. If target accepts (maybe they click an "Accept trade" button triggered by an event), then open a trade window on both sides. In the trade window, allow each to select items from their inventory to offer (maybe limit to 1 item each for simplicity). When both click Confirm, server swaps the items between inventories and sends updates. This is quite complex to do properly, so likely skip unless core done and significant time left.  
- [ ] **(Optional) Mobile Support** – Adjust CSS and controls for smaller screens. This could include adding a virtual joystick (there are libraries or one can make a draggable circle that updates an analog direction, which then maps to movement). Also ensure touch events can be used for camera (like dragging finger to rotate camera) and tapping for interactions. Test on a mobile device browser if possible. Also resize UI elements to be larger for touch.  
- [ ] **(Optional) Visual Improvements** – Swap out the simple shapes with better models if available. For example, use an actual tree model (perhaps a low-poly tree from a free asset library) and load via Three.js GLTFLoader. Use a character model for players (maybe a primitive humanoid or even a sphere for head and capsule for body). Add basic animations: e.g., when moving, play a "walking" animation or just bob the model. For woodcutting, you could animate the tree or the player (swing an axe animation if we had one). Add particle effects or sound for extra feedback. These things enrich the game but each can take significant time, so only attempt if ahead of schedule or for future development.  
- [ ] **(Optional) Persist Player Data** – Integrate a backend database (could be a simple file or an actual DB) to save player info (name, inventory, maybe position) so that if the server restarts or player reconnects, they resume where they left off. This would involve hooking into join/disconnect to load/save data. Perhaps use Next.js API routes or direct Node fs calls to store JSON. With limited time, this might be skipped, but it's a logical next step after the prototype is stable. 