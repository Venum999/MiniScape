# MiniScape Implementation Plan


Great! I’ll create a mid-level granularity implementation checklist and design document for the full game – including frontend, backend, multiplayer networking, and core gameplay systems – specifically structured so a Claude-based agent in Cursor can execute the tasks step-by-step.

I’ll break this down by components (e.g. setup, rendering, multiplayer, gameplay mechanics) and ensure each task is clearly defined for LLM execution, including file responsibilities and logic expectations. I’ll get that ready for you shortly.

# Introduction  
 ([Multiplayer Games with React Three Fiber and WebSockets by Maya Nedeljković Batić](https://gitnation.com/contents/multiplayer-games-with-react-three-fiber-and-websockets#:~:text=Multiplayer%20games%20are%20the%20coolest%3A,between%20the%20client%20and%20server))Creating a browser-based multiplayer RPG inspired by **RuneScape** is an achievable goal even without a large game studio. By leveraging modern web technologies (React, Three.js, WebSockets, etc.), we can build an engaging 3D MMO-like experience that runs in the browser ([Multiplayer Games with React Three Fiber and WebSockets by Maya Nedeljković Batić](https://gitnation.com/contents/multiplayer-games-with-react-three-fiber-and-websockets#:~:text=Multiplayer%20games%20are%20the%20coolest%3A,between%20the%20client%20and%20server)). The game will emphasize real-time social interaction—players exploring a 3D world together, chatting, and skilling (woodcutting, mining, fishing)—much like the classic RuneScape gameplay loop. Our target is a **desktop browser** experience (with basic mobile support as a stretch goal) that supports ~20 concurrent players in the same world. The plan outlined here includes a technical architecture overview and a step-by-step implementation checklist to incrementally build the full game within roughly **35 hours** of development time. Core features will be prioritized, while optional polish (like PvP combat in the Wilderness or advanced trading interfaces) will be clearly marked as stretch goals.

# Technical Design Document  

## Project Overview and Scope  
This project is a small-scale 3D multiplayer RPG for the web, inspired by the world and mechanics of RuneScape. Players will be able to create a character (no login system initially, just a chosen name), move around a 3D world, see and chat with other players, gather resources (e.g. chop trees, mine rocks, fish at water), manage an item inventory, and drop/pickup items. The game world will be divided into a few **zones** resembling RuneScape locales: **Lumbridge** (starting safe zone with trees and a river), **Barbarian Village** (contains a mine with coal rocks), **Grand Exchange** (social/trade hub, mostly for chat and meeting), and the **Wilderness** (a dangerous area where PvP could be enabled as an optional feature). The core objective is to deliver a realtime shared world with basic RPG mechanics and a strong social component (chat and presence), rather than complex combat or quests (those can be future enhancements).

Key requirements and assumptions:  
- Support ~20 simultaneous players in one session/world. This is a relatively low number, which simplifies networking and server load concerns. We can manage all players in a single instance of the world and broadcast updates to everyone. No sharding or multi-instance support is needed for this scope.  
- Emphasize real-time synchronization: movement and chat updates from any player should be seen by all others almost immediately. Resource gathering and item drops should also propagate to all players so the world state stays consistent.  
- Use simple placeholder graphics and models to save time. For example, the player model can be a simple colored cube or low-poly character, resource nodes (trees/rocks) can be basic models or primitives, etc. Focus is on functionality over visual fidelity within the 35-hour build window.  
- No persistent account or long-term saving (unless time permits). Each server run is an ephemeral session; if a player refreshes or disconnects, their inventory and position can be reset. (Stretch goal could be to persist some state in a simple database, but not required for core.)  
- Prioritize essential features first (movement, multiplayer sync, chat, basic gathering) and ensure they are solid. Secondary features like PvP combat or advanced trading systems will only be attempted if time allows, after core mechanics are done.

## Tech Stack Choices  
Our stack leverages powerful web frameworks that allow fast development of a multiplayer 3D game:  

- **Next.js (Node.js + React, TypeScript)** – Provides a unified project for both frontend and backend. We will use Next.js pages or a single-page app for the game client, and Next.js API routes (Node.js) for backend logic (including the WebSocket server). TypeScript helps catch errors early and provides clear interfaces for game objects and network messages.  
- **Three.js** – A high-level 3D graphics library on top of WebGL, used for rendering the game world in the browser. Three.js makes it easier to create and display 3D scenes without needing to write raw WebGL shaders ([Menubar](https://menubar.io/multiplayer-game-threejs/#:~:text=,event%20streams%20like%20keydown%20events)). It will handle the rendering loop, cameras, lighting, and 3D models for players and environment.  
- **React** – Handles the UI overlay and interactive components (chat box, inventory panel, perhaps health or skill displays). Using React alongside Three.js allows us to build UI panels declaratively while managing the 3D canvas imperatively. Next.js’s React framework also lets us easily manage the overall application and possibly server-side rendering (though the main 3D scene will render client-side).  
- **WebSockets (e.g. Socket.IO or native WebSocket)** – Enables real-time bi-directional communication between clients (players) and the server. Unlike HTTP request/response, WebSockets maintain a persistent connection so the server can push updates to clients instantly ([Building a multiplayer game using WebSockets - Part 1 - DEV Community](https://dev.to/sauravmh/building-a-multiplayer-game-using-websockets-1n63#:~:text=Why%20WebSockets%20and%20not%20HTTP%3F)). This is critical for multiplayer game state sync (e.g. broadcasting player positions or chat messages). We can use either the native WebSocket API or the more convenient Socket.IO library. Socket.IO provides built-in reconnect logic and event-based messaging which can speed up development.  
- **Node.js (Next.js API backend)** – The server logic will run on Node (via Next’s API routes or a custom server). Node is well-suited for handling multiple WebSocket connections concurrently and has a simple event-driven model ([Multiplayer Game With WebSockets. Perhaps the best and most enjoyable way… | by diegolikescode | Medium](https://medium.com/@diegolikescode/multiplayer-game-with-websockets-fd629686aaec#:~:text=I%20used%20Node,the%20game%20in%20his%20localhost)). Using Node allows our server to share code with the client (e.g. data models or message types) and to use the same language (TypeScript/JavaScript) across the stack.  

Overall, this stack is proven for browser multiplayer games: **HTML5 + Node.js + WebSocket** technology has been used successfully to create real-time browser games without plugins ([Architecture of a Node.js multiplayer game | by Michał Męciński | Medium](https://medium.com/@MichalMecinski/architecture-of-a-node-js-multiplayer-game-a9365356cb9#:~:text=Technologies%20such%20as%20HTML5%2C%20Node,ins)). With React and Three.js on the frontend, we balance game rendering and UI needs, and with Node/WebSockets on the backend, we handle real-time game state management.

## Architecture Overview  
The game follows a client-server architecture with authoritative server state for critical game data. Each player runs a **client** (the Next.js React app with a Three.js scene) which connects to a central **server** (Next.js Node backend) via WebSocket for realtime updates. Below is a breakdown of the major components on each side and their responsibilities:

- **Client (Browser)**:  
  - *Three.js Game Scene*: Renders the 3D world (terrain, environment objects, player avatars). Also handles user input (keyboard for movement, mouse clicks for interactions) and immediate visual response (moving the local player, etc.).  
  - *React UI Components*: Manages on-screen GUI such as the chat window, inventory interface, and possibly health/skill bars. These components interact with the game state (for example, the inventory component will reflect items the player has, and the chat component will display incoming messages).  
  - *Client Game State*: Keeps track of local player's state (position, stats, inventory) and a local copy of other players’ states as last received from the server. The client interpolates or instantly updates positions for smooth visuals.  
  - *Network Module (WebSocket Client)*: Listens for messages from the server (e.g. other players’ movements, chat messages, world events) and sends messages for the local player’s actions (movement commands, chat text, item pickups, etc.).  

- **Server (Node.js via Next.js API)**:  
  - *WebSocket Server*: Accepts socket connections from each client. Manages a list of connected players. It receives messages from clients and broadcasts updates as needed. For example, when a player moves or performs an action, the server receives that data and sends it out to other clients. We may use Socket.IO on the server for convenient event handling (e.g. `playerMoved`, `chatMessage` events).  
  - *Game State Management*: The server maintains the authoritative state of the world: all player positions, the locations and availability of resource nodes (trees, rocks, fishing spots), and dropped items in the world. It may also enforce game rules (e.g. preventing movement through walls, or checking if a resource is still available to gather). Because we only have ~20 players and a simple world, keeping all state in memory is feasible. Data can be stored in plain objects/structures (e.g. a map of playerId → position, a list of active dropped items with coordinates, etc.).  
  - *Game Logic Controllers*: On the server side, small controllers will handle specific game mechanics. For instance, when a “gather resource” action is received, server logic can determine if the player is in range of a resource and if so, generate the item (e.g. a log from a tree) and update the world state. Similarly, dropping an item would update server state and trigger a broadcast to spawn an item entity for all players. Combat (if implemented) would be resolved on the server as well (calculating damage, updating health).  
  - *Next.js API Routes*: Next.js allows defining API endpoints (e.g. `/api/socket`) that can run server-side code. We will likely initiate our WebSocket server in such a route or during the Next.js server startup. The HTTP portion of Next.js (pages routing) may not be heavily used beyond serving the main game page, since most interactivity happens via WebSockets after initial load.  

This setup is fairly typical for a real-time web game: a Node server to handle game state and multiple React clients connected over WebSockets ([Multiplayer Games with React Three Fiber and WebSockets by Maya Nedeljković Batić](https://gitnation.com/contents/multiplayer-games-with-react-three-fiber-and-websockets#:~:text=How%20is%20the%20server,set%20up%20for%20React%20Battleship)). The server will act authoritatively for consistency (e.g. it decides the official positions of players and the outcomes of actions), but the client will also optimistically move the local player immediately for responsiveness. For example, when you press a movement key, your character moves on your screen right away (client-side), and a message is sent to the server and then out to other clients so they see your movement. In this small-scale game, we might not implement complex lag compensation – the immediate update plus eventual server correction (if needed) should suffice given likely low latency in a 20-player scenario.

**Communication Protocol:** We will define a simple message protocol for client-server communication. Using Socket.IO (if chosen), we can emit events like:  
- `playerJoined` (server → all clients): Broadcast when a new player connects, with their initial state (id, name, starting position). Clients will spawn a new avatar in their scene.  
- `playerMoved` (client → server, then server → all): Sent whenever a player moves (could be at a fixed tick or when position changes). Contains the player’s id and new coordinates (and maybe direction). The server updates that player's position in its state and relays it to others.  
- `chatMessage` (client → server → all): When a player sends a chat text, server tags it with the player’s name and broadcasts to everyone to display in chat UI.  
- `gatherAction` (client → server): e.g. player tries to chop a tree. Contains the action type and target resource id. Server can validate (player is near the tree and the tree is available) then respond with an item gain. Possibly server emits an event like `resourceCollected` or directly an `inventoryUpdate`.  
- `inventoryUpdate` (server → specific client or all): Could send when a particular player's inventory changes. Inventory could also be kept only on client until an action like drop/trade happens – we need to decide if inventory is authoritative on server. For simplicity, we might let the client track its own inventory except when sharing is needed (dropping). But to prevent cheating and for consistency, a safer approach is the server tracks all items. Given time constraints, a hybrid approach may be used (client manages inventory locally, but sends messages to server on changes so it can inform others of drops, etc.).  
- `itemDropped` (client → server → all): When a player drops an item, the server will remove it from that player’s inventory and create a world item entity at that location, then broadcast to all clients to spawn the item in their scene.  
- `itemPicked` (client → server → all): When a player picks up a world item, server will remove that item from the world state and add to the player’s inventory, and notify all clients to remove the item from the scene (and maybe notify only that player to add to their inventory if we do server-authoritative inventory).  
- (Optional) `attack` or `playerHit` events for PvP if implemented in Wilderness.  

Using event names for each distinct action keeps things organized. The payloads will be JSON data (Socket.IO handles this easily). This simple protocol is akin to how a chat app works, which is fitting because a multiplayer game is essentially a superset of a chat—similar message broadcasting mechanics apply ([How to create a multiplayer fps three js game - Questions - three.js forum](https://discourse.threejs.org/t/how-to-create-a-multiplayer-fps-three-js-game/55626#:~:text=makc3d%20%20September%202%2C%202023%2C,9%3A05pm%20%204)).

## Gameplay Mechanics Design  
Now we break down how each core mechanic will work and be implemented:

- **Player Movement:** Players move in the 3D world using keyboard controls (WASD or arrow keys for directional movement). We’ll implement a third-person or top-down camera that follows the player avatar. Movement will likely be restricted to an X-Z plane (horizontal movement) since this is an RPG-like world – jumping is not necessary. When a player moves, their client will update their avatar’s position locally and simultaneously send their new position (or movement vector) to the server via WebSocket. The server then broadcasts that to other clients so all avatars update. We may send movement updates continuously (every frame or at a set tick, e.g. 10 times per second) to ensure smooth motion; or we can send discrete start/stop events (e.g. “player started moving north”). A simple approach is to send the current position every small interval. With ~20 players this is manageable. The movement system should also handle basic collision or boundaries: e.g. do not allow walking through certain objects or outside the world limits. For simplicity, we can implement axis-aligned boundaries for the zone edges (Lumbridge, etc.) and maybe rudimentary collision by not letting the player coordinate go inside a tree or rock’s area. (Full physics or navmesh is out of scope; we can approximate or just trust players not to glitch through objects for now.) The **camera** will be positioned to give an isometric or third-person view of the player. We might use a Three.js `PerspectiveCamera` angled slightly downward toward the player, or a simpler overhead `OrthographicCamera` if we want a classic RPG look. The camera will update its position whenever the player moves, so the player stays roughly centered on screen.  

- **Chat System:** A real-time chat is crucial for the social aspect. The UI will have a chat panel (for example, a semi-transparent box at the bottom-left) showing a log of messages and an input field for the player to type in. When the player submits a message, it will be sent to the server via WebSocket (`chatMessage` event) and then broadcast to everyone. The server can prepend the sender’s name to the message. On receiving a chat message event, clients will append it to their chat log UI. We’ll implement basic chat only (no private messaging or channels). Chat messages will also likely appear in a text overlay in the 3D world (like above the player’s head) only if we have time – at minimum, the chat panel is sufficient. The chat component can be a React component separate from the Three.js canvas, floating over or under it in the layout. We should ensure that focusing the chat input stops controlling the player (i.e., when you’re typing, your WASD should not move the character). This can be handled by toggling an input mode or simply by checking if the chat input is focused before moving the player.

- **World Zones and Environment:** The game world will be a single Three.js scene encompassing all zones (Lumbridge, Barbarian Village, etc.). We’ll represent different areas perhaps just by their coordinates or simple delineations (e.g., a different ground color or some landmarks). Given time constraints, the “world” might not be very large – possibly a flat plane with some distance between these key points of interest. For example, we can have a ground plane or terrain mesh that spans everything, and use simple models to mark Lumbridge (like a small building or sign), Barbarian Village (some barbarian hut or mine entrance), Grand Exchange (maybe a circular platform), and Wilderness (change ground texture to darker and maybe place a boundary line). These are purely for visual flavor; the important part is to define certain coordinates as Wilderness so we know to allow PvP there. We might maintain an enum or constant mapping: e.g., if x,z coordinates are north of a certain line, we consider the player in Wilderness. Lumbridge can be near origin (0,0), Barbarian Village maybe to the north-west, Grand Exchange to the north-east, etc., roughly mimicking their positions in RuneScape. We won’t implement transports or anything—players will just walk between these areas. The environment will include **resource nodes**: e.g., some tree objects in Lumbridge that can be chopped, some rock objects in the Village mine to be mined, and perhaps a water plane at the river for fishing. Each resource node can be a Three.js mesh (tree model or simple cylinder for a tree trunk, for example) with an identifier. The positions of these resources will be known to both client and server (we can hardcode them or load from a small config). Resources might respawn after a delay if we simulate depletion (optional given short timeframe; we might assume infinite resources for simplicity—players can chop the same tree indefinitely). The Wilderness area could optionally contain some aggressive monsters or just be an empty PvP zone. Monsters or NPCs are likely out of scope to implement fully, so Wilderness might simply be an area where players *could* attack each other if PvP code is done.

- **Resource Gathering (Woodcutting, Mining, Fishing):** These three skills function similarly: the player uses a resource node and gains an item. Design: The player must move their character near a resource (within a certain radius) and perform an action (maybe clicking on the object or pressing a key like “F” or a button in the UI). Once the action is triggered, we can simulate a short delay (e.g. 3 seconds “gathering” time) possibly with a simple progress indicator, then produce an item (like a log, coal, or fish) that goes into the player’s inventory. For implementation, when the client detects the gather action, it will send a message to server: e.g. `{ type: "gather", resourceId: X }`. The server will check if that resource is available (not already depleted if we track that, but we may ignore depletion) and then respond to that client with an `inventoryUpdate` event giving them the new item, and possibly broadcast a message to others if we want others to see an animation or just to know that player is woodcutting (not strictly necessary to broadcast, could be purely local visual effect). However, for realism, if we want others to see a tree “being chopped down,” that’s more complexity (likely out of scope). So we will simply handle resource gathering as: when you gather, you get the item. We won’t remove the resource from the world for others. (Stretch: maybe add a cooldown on that resource per player to throttle item gain). Each skill yields a specific item: woodcutting -> logs, mining -> ore (coal for Barbarian Village), fishing -> fish. These items will be represented by simple identifiers or objects (e.g., `{ name: "Log", id: 1 }`). No detailed stack sizes or quality levels are needed; just assume each action yields one unit of the item.

- **Inventory System:** The player inventory holds the items they have collected. We can represent it as a list or array in state. A reasonable limit (not that it matters much here) could be 28 items like RuneScape, but we likely won’t reach that. The inventory UI will be a React component, perhaps a grid or list showing item icons or names. Given time and simplicity, we might just display a list of item names with quantities. Each time the player receives an item (from gathering or picking something up), we update this list. If using React state for inventory, we must ensure it updates whenever an `inventoryUpdate` is received from the server. For dropping items: in the inventory UI, each item entry might have a “Drop” button. If the player clicks drop, we send a message to server `dropItem {itemType}` (and possibly the amount or slot). The server on receiving this will remove that item from the player’s inventory on the server-side record and create a world drop. The world drop can be represented by a small object in the scene (e.g. a little mesh or icon at the player’s position). That drop should be broadcast to all clients as an `itemDropped` event with an id, type, and position. Clients will spawn the item in their Three.js scene so anyone nearby can see it. To pick up an item from the ground, the player would need to move near it and perhaps click it. We can simplify pickup by allowing the player to just walk over it to trigger pickup, or press a key when in range. Implementation-wise, we can check on the client every frame if the player’s position is near any dropped item; if yes, maybe highlight it or show a “Press E to pick up” prompt. On pressing, send `pickup {itemId}` to server. Server then gives that item to the player (if it still exists) and sends `inventoryUpdate` and an `itemRemoved` to all to despawn it. Inventory management will primarily be client-side logic (updating the UI, local state) with server as the source of truth for additions/removals via events.  

- **Grand Exchange (Trading/Social)**: The Grand Exchange zone in RuneScape is a complex marketplace. For our scope, we will not implement a full trading interface or economy. Instead, the Grand Exchange in our game can simply be a meeting area where players might drop items to give to others or just congregate to chat. If time permits as a stretch feature, we might add a very basic direct trade: e.g., one player can send a trade request to another which opens a simple modal where each can offer items and click accept. However, this is non-trivial to get right and likely beyond 35 hours with everything else. So we will consider **item dropping** as the primary way to exchange items between players for now (i.e., drop an item on the ground and someone else can pick it up). We will document trading as a potential future addition.

- **Wilderness (PvP Combat)**: The Wilderness is an optional PvP zone. If time allows, we can add a bare-bones combat system here. A simple approach: if two players are in the Wilderness, they can attack each other by clicking on the other player’s avatar or pressing an attack button when target is near. We would then exchange some attack messages. Combat could be very rudimentary: each player has a health stat (say 100 HP), and an attack simply reduces the target’s health by a fixed amount (e.g. 10). We won’t implement different weapons or damage types in this timeframe. The server would handle the sequence of an attack: when a client issues an attack, server checks that both players are in Wilderness and not recently attacked (to perhaps add a short cooldown), then deducts health from the target and broadcasts a `playerHit` event with the new health. If health reaches 0, we can broadcast a `playerDied` (and possibly drop that player’s inventory as loot on the ground for fun). This is clearly a stretch goal—if implemented, it will be very simple and likely without animations. We will mark this as optional tasks at the end.  

- **Performance Considerations:** With up to 20 players and a moderately sized simple scene, performance should be manageable on modern browsers. Three.js can handle a few hundred simple objects easily. We will use basic materials (likely just solid colors or simple textures) and limit light/shadow complexity to keep frame rates high. Network-wise, the volume of data is small: position updates (maybe 20 bytes each) broadcast 10 times per second to 20 clients is a few KB/s, which is fine. We will still be mindful to not send messages more frequently than needed (e.g., possibly throttle movement messages to a fixed tick). Also, we’ll ensure to clean up event listeners and arrays (like when a player disconnects, remove them from world state and inform others) to avoid memory leaks or ghost objects.  

 ([Multiplayer Games with React Three Fiber and WebSockets by Maya Nedeljković Batić](https://gitnation.com/contents/multiplayer-games-with-react-three-fiber-and-websockets#:~:text=The%20game%2C%20React%20Battleship%2C%20uses,React%20context%20is%20used%20for))It’s worth noting that while our server will handle the authoritative game state and logic for fairness, we’ll strive to keep the game feeling responsive by doing client-side predictions (like immediate movement). Given the small scale, we might not implement full client-side prediction and reconciliation as one would in a larger FPS game, but we acknowledge the principle that user actions should be reflected instantly client-side without waiting for server confirmation ([Multiplayer Games with React Three Fiber and WebSockets by Maya Nedeljković Batić](https://gitnation.com/contents/multiplayer-games-with-react-three-fiber-and-websockets#:~:text=The%20game%2C%20React%20Battleship%2C%20uses,React%20context%20is%20used%20for)). For example, when you click a tree to chop, we might locally display chopping animation or text right away, while in parallel the server processes the action. This way, even if there’s slight delay, the player isn’t left waiting with no feedback.

## UI and Controls  
The user interface will be minimal but functional:  

- **Game Canvas**: The Three.js canvas will likely take up the full browser window, rendering the 3D world. We will overlay UI elements on top of this canvas using typical HTML/CSS. This could be done by absolutely positioning React components over the canvas or by using a separate DOM overlay. Next.js/React will manage these as part of the page.  

- **Chat Panel**: As described, a panel at bottom (or side) showing chat messages. We can limit it to showing the last ~50 messages. It should auto-scroll as new messages come in. The input box allows the player to type and send on Enter key. We will capture that event and trigger the send. Style can be simple (white text on semi-transparent dark background).  

- **Inventory Panel**: Possibly on the right side of the screen, we’ll have an inventory list. Each entry might show an item name and quantity. If we have small icons (maybe we can use emoji or simple images as icons), we could show those too. A “Drop” button next to each item allows dropping it. We might also allow clicking the item to use it (though we have no consumables implemented aside from fish maybe being food? That’s a stretch to consider healing – probably not now). So main interaction is drop. The inventory panel could be collapsible or always visible; due to simplicity, always visible might be fine if it doesn’t clutter.  

- **Player Name/Stats Display**: We should display the player’s own name somewhere (especially if we allow changing name on start). Also perhaps their health if we do PvP. For MVP, we might skip a detailed stats HUD since no leveling system or HP is in core scope except optional PvP. But to prepare for PvP, we might include a small health bar on top of each player in Wilderness or a generic one for yourself on screen.  

- **Controls**: WASD or arrow keys for movement, plus maybe mouse drag to rotate camera if we allow camera control. Alternatively, we might keep camera fixed orientation to simplify. Interactions (like clicking on resources or items) will use the mouse. We will need to do raycasting in Three.js from mouse clicks to detect if a resource or item object was clicked. Three.js provides raycasters that we can use with the list of interactive objects. If a click hits a tree object, we treat it as a woodcut action, etc. Keyboard keys: we might map keys for convenience, e.g. “Enter” to focus chat (or just clicking the chat input), maybe number keys if we had hotbar (not needed now). For picking up items, maybe the **E key** when near an item to pick it up, or we just rely on click. Ensuring that when the chat input is focused, movement keys don’t move the character is important (we can handle this by a simple check or a modal chat mode).  

- **Responsive Design**: Since desktop is primary, we will design UI for a typical 1280x720 or larger window. If we have time to adjust for mobile, that might involve adding on-screen joystick and making sure touch events can control movement and camera. This is a stretch goal. The architecture (React + Three) is capable of running on mobile browsers too ([stein.world by pg5-Studio](https://pg5-studio.itch.io/steinworld#:~:text=In%20addition%20stein,anywhere%2C%20at%20anytime%2C%20on%20anything)), but we won’t optimize for it initially aside from maybe ensuring the canvas resizes to smaller screens.

 ([Ironbane - The MMO game you can play right in the browser - Showcase - three.js forum](https://discourse.threejs.org/t/ironbane-the-mmo-game-you-can-play-right-in-the-browser/48552#:~:text=Ironbane%20))To get a sense of the end-goal, consider a small MMO rendered in the browser: players, stats, and chat can all be displayed via the web interface. For instance, one prototype shows a 3D character with an on-screen HUD for stats and a chat log, all running directly in the browser ([Ironbane - The MMO game you can play right in the browser - Showcase - three.js forum](https://discourse.threejs.org/t/ironbane-the-mmo-game-you-can-play-right-in-the-browser/48552#:~:text=Ironbane%20)). This is the kind of experience we aim to create on a smaller scale.  

 ([Ironbane - The MMO game you can play right in the browser - Showcase - three.js forum](https://discourse.threejs.org/t/ironbane-the-mmo-game-you-can-play-right-in-the-browser/48552)) *Example of a browser-based 3D MMO interface: a player character in a Three.js world with a simple HUD (health, stats) and a chat log. Our game will implement similar on-screen elements for player status and chat.*  

 ([Multiplayer Voxel Parkour Game (three.js + rust) - Showcase - three.js forum](https://discourse.threejs.org/t/multiplayer-voxel-parkour-game-three-js-rust/40948#:~:text=My%20friend%20and%20I%20are,voxel%20parkour%20game%2C%20Voxelize%20Realms))Achieving a lively multiplayer world is feasible with this stack, as demonstrated by other web-based games showing multiple players interacting in real time. In a voxel-style example, several player avatars can be seen in the same world with their names and actions synchronized instantly ([Multiplayer Voxel Parkour Game (three.js + rust) - Showcase - three.js forum](https://discourse.threejs.org/t/multiplayer-voxel-parkour-game-three-js-rust/40948#:~:text=My%20friend%20and%20I%20are,voxel%20parkour%20game%2C%20Voxelize%20Realms)). Our game will likewise render all nearby players in the scene and update their movements and actions live via the network.  

 ([Multiplayer Voxel Parkour Game (three.js + rust) - Showcase - three.js forum](https://discourse.threejs.org/t/multiplayer-voxel-parkour-game-three-js-rust/40948)) *Real-time multiplayer in a browser: multiple players (with labels over their heads) coexist and move in a shared 3D environment. Our RuneScape-inspired game will similarly sync players’ positions and actions so everyone can see each other in the world.*  

## Stretch Goals and Future Improvements  
We will focus on core features first, but if time permits or for future iterations, the following enhancements are considered stretch goals (optional tasks):  

- **Player vs Player Combat**: Implement basic PvP combat in the Wilderness zone. This includes adding a health attribute to players, an attack action, and a mechanism to reduce health and possibly drop loot on death. Combat balancing, different weapons or armor, and safe-zone protection (no PvP outside Wilderness) would be part of this. Due to complexity, we’d implement the simplest version (e.g., click to deal fixed damage).  
- **Trading System or Item Exchange**: Instead of only dropping items on the ground, a direct trade interface between players could be added. This would involve a request/accept flow and a UI to offer items and confirm a trade. Because ensuring fairness (both sides accept simultaneously) can be tricky, we might do a simplified “consent and swap” approach. This is a significant feature so likely only if other tasks finish early.  
- **NPCs or Enemies**: Populate the world with a couple of non-player characters or monsters (for example, a Goblin in Lumbridge or some Barbarian NPCs) that could interact or be attacked. This would mostly be cosmetic or for atmosphere unless we tie into combat.  
- **Skill Advancement**: Track skill levels for woodcutting, mining, fishing, etc., and award experience for each action. Over 35 hours this is probably too much, but it’s a classic part of RuneScape. We’d need a way to persist or at least session-track levels, and maybe adjust success rates or add an XP UI. Probably out of scope for now.  
- **Persistence**: Integrate a simple database or storage so that if the server restarts or a player reconnects, their stats and inventory could be restored. This would involve user accounts (even if just a username or ID) and storing their data. Could use something like SQLite or even a JSON file for simplicity.  
- **Mobile Controls and UI**: If targeting mobile, we’d implement touch controls (perhaps a virtual joystick for movement and on-screen buttons for actions/chat) and scale the UI appropriately. Also optimize performance for mobile GPUs. This is non-trivial, so considered only if core done very early.  
- **Graphics Improvements**: Replacing primitive placeholder models with nicer 3D models (there are free models for trees, characters, etc.), adding animations (e.g., a chopping animation or a walking animation for players), sound effects for actions, and maybe rudimentary lighting/shadows to enhance visual appeal. Also possibly a mini-map or an on-screen compass to help navigation between zones. These refinements can greatly improve the experience but are secondary to functionality.  

All these stretch features are nice-to-have; the primary goal is to get a working multiplayer world with chat and resource gathering. The following **Implementation Checklist** breaks the development into sequential tasks an LLM agent (or developer) can execute, grouped by subsystem. Each task is scoped to produce a tangible piece of the game, building up to the final product. Optional tasks (stretch goals) are clearly marked and would be tackled after the core is complete.

# Implementation Checklist  

Below is a step-by-step plan to implement the game. Tasks are organized by functional area, roughly in the order they should be executed. Each task is described in terms of what needs to be done. An LLM agent (like Claude in Cursor) could be directed to perform each step in sequence. Core tasks should fit in about a 35-hour timeline; optional tasks for stretch goals are listed last.  

## Project Setup and Initialization  
1. **Set up Next.js TypeScript project** – Initialize a new Next.js app (using `create-next-app` or manually). Ensure TypeScript is configured. Verify the development server runs. Create a clean repository structure.  
2. **Install Dependencies** – Add required libraries: Three.js (`npm install three`), Socket.IO client and server (`npm install socket.io socket.io-client`) or if using native WebSocket, none needed for client as browser has it (and `ws` for server). Also add any helper libraries if needed (possibly none). Confirm `package.json` has all: react, react-dom (Next includes them), three, socket.io, etc.  
3. **Basic Next.js page for game** – Create a main page (e.g., `pages/index.tsx`) that will host the game. This page will eventually contain the Three.js canvas and React UI components. For now, put a placeholder “Game is loading…” text to verify routing works.  
4. **Project structure** – Set up a logical structure: maybe a folder for components (React UI components like ChatPanel, InventoryPanel), a folder for game logic or Three.js related code (maybe `game/` containing modules for world, player, etc.), and possibly a folder for server (though if using Next API, that goes under `pages/api`). Create stub files or at least plan these out.

## Three.js Rendering Engine Setup  
5. **Create Three.js scene canvas** – Implement a React component that initializes a Three.js scene, camera, and renderer. This could be done in `pages/index.tsx` or a dedicated `<GameCanvas>` component. Use a `useEffect` hook to set up the scene after the component mounts. Basic steps: create a `THREE.Scene`, a `THREE.PerspectiveCamera` (e.g. fov 75, aspect from window size, near 0.1, far 1000), and a `THREE.WebGLRenderer` attached to a canvas. Append the canvas to the DOM or use a `ref` on a canvas element in JSX. Start an animation loop with `requestAnimationFrame` to render the scene each frame. Verify that you see a blank canvas (black screen by default) covering the page.  
6. **Add simple environment** – In the Three.js scene, add a ground plane to represent terrain. For example, create a large `PlaneGeometry` with a grass-green material. Orient it flat (rotate X by -π/2 if needed so it lies horizontally). Add some basic ambient light (`THREE.AmbientLight`) and maybe a directional light (to have some shading). Also, set the camera position somewhere above the ground looking down (e.g., camera at (0, 50, 50) looking at (0,0,0)). This establishes the world space. Render and ensure the ground is visible (you might need to set `renderer.setClearColor` to sky blue to simulate sky).  
7. **Player avatar placeholder** – Create a simple placeholder for the player character in the scene. This could be a `THREE.Mesh` using a `BoxGeometry` or `SphereGeometry` with a distinct color (representing the player). Position it at the starting location (e.g., near (0,0,0) on the ground). For now, this is just a static mesh. In the future, we’ll have one for each player, but start with one for the local player. Confirm it renders properly above the ground.  
8. **Camera follow logic** – Implement camera movement to follow the player. For example, on each frame in the render loop, update the camera position to some offset behind/above the player’s position. A simple method: camera.position.x = playerMesh.position.x, camera.position.z = playerMesh.position.z + some offset, camera.position.y = playerMesh.position.y + some height. Or keep camera looking at player while orbiting. For now, even a fixed-position camera that still shows the player is fine. This step ensures as the player moves (next steps) the camera will track them, keeping the player in view.  

## Player Movement Controls  
9. **Input handling for movement** – Set up event listeners for keyboard input (WASD/arrow keys). In the React component or in a separate input module, add `keydown` and `keyup` event listeners. Track which keys are currently pressed (e.g., an object like `{ up: false, down: false, left: false, right: false }`). On each animation frame, if keys are pressed, adjust the player’s mesh position accordingly. For example, if “W” or Up is pressed, increase playerMesh.position.z by +speed*delta or something (depending on coordinate system orientation—if camera is facing negative Z as forward, adjust accordingly). Do similar for S/D/A for backwards/right/left. Use a reasonable speed so the movement looks natural. Test that you can move the placeholder player around with the keyboard locally.  
10. **Constrain movement area** – To simulate world boundaries and distinct zones, implement simple limits: e.g., if player tries to move beyond x = ±50 or z = ±50 (world edge), stop them. We can later refine to zone shapes, but a bounding box for the walkable area is fine initially. Also prevent movement through the ground (y axis not used). If inclined, also avoid going through objects by rudimentary checks (like if near a tree object, maybe stop, though this can be complex without physics—skip detailed collision for now or treat resource objects as non-solid).  

## Basic Multiplayer Networking  
11. **Set up WebSocket server (Socket.IO)** – Implement a Next.js API route for the WebSocket server. Create a file like `pages/api/socket.ts`. In it, disable Next.js’s default body parser (since we’ll upgrade to WS). Initialize a Socket.IO server or a raw WebSocket server. (Using Socket.IO: you can check if an instance is already running to avoid duplication when Next hot-reloads; often a global instance or store it on `res.socket.server.io`). Set it up to listen for connections. When a new client connects, print a log to verify. This effectively creates the WebSocket endpoint (e.g. at `/api/socket`). Next, on the client side, connect to this socket.  
12. **Connect client to WebSocket** – In the client code (maybe in a useEffect in the main game component), create a Socket.IO client connection to the server. The URL could be the same origin (e.g. just `io()` will auto-connect to the same host if Socket.IO script is loaded, or use `ws://localhost:3000/api/socket` if raw WS). Make sure to include the Socket.IO client script by importing from `socket.io-client`. Attempt to connect and listen for a “connect” event to confirm connection. Test by running the app, opening two browser windows, and see on server logs that two clients connected.  
13. **Broadcast new player to others** – Implement on the server: when a client connects, assign them a unique ID (Socket.IO already has `socket.id`). You can also accept a username (perhaps the client emits a “join” message with their desired name). Keep a list (or object) of players on the server, storing at least their id, name, and initial position. Then notify existing players about the new player, and notify the new player about all existing players (so they can spawn them). Concretely: on new connection, server could broadcast a `playerJoined` event `{id, name, x, y, z}` to all *other* clients. And send the new client a `initPlayers` event containing an array of all current players (their ids, names, positions) so the client can populate the world with those. Implement the corresponding client-side handlers: on `playerJoined`, add a new avatar mesh to the scene for that player; on `initPlayers`, loop through the list and create avatars for each existing player. Use a different color or model for other players vs the local player to distinguish (maybe local is blue, others are red). At this point, if you open two clients, you should see two avatars in each (but not moving yet).  
14. **Handle player disconnect** – In the server, listen for disconnect events (`socket.on('disconnect')`). When a player disconnects, remove them from the server’s player list and broadcast a `playerLeft` (with that player’s id) to all remaining clients. On the client, handle `playerLeft` by removing that player’s mesh from the scene (and maybe removing them from any local state tracking). This prevents orphaned avatars if someone leaves.  

## Real-Time Movement Synchronization  
15. **Send movement updates** – Now integrate movement with networking. On the client, whenever the player’s position changes (from the movement controls), emit a `playerMove` event to the server. Throttle this to, say, 10 times per second to avoid overloading (e.g., use `setInterval` or track elapsed time in the render loop to send at fixed intervals). The message can contain the player’s id (or rely on socket id on server side) and their new coordinates (and maybe direction if needed). On the server, listen for `playerMove` events from clients. When received, update that player’s stored position in the server state, and broadcast a `playerMoved` event to all other clients with `{id, x, y, z}`. The server might choose to emit this only to others (not back to sender) to avoid echo (since the sender already moved locally). Alternatively, send to all including sender and the sender can ignore self updates.  
16. **Receive and apply movement** – On each client, implement handler for `playerMoved` event. When a message arrives, find the corresponding player’s mesh in the scene and update its position to the provided coords. This will make other players appear to move. Make sure to differentiate local vs remote: the local player’s movements come from input, not network, so you might not receive a `playerMoved` for yourself if server didn’t echo it. If you do receive your own (depending on implementation), you can ignore or use it for correction if needed. Now test with two browsers: moving in one should cause the avatar in the other to move. There might be slight latency but it should update smoothly if messages are frequent. Fine-tune as needed (possibly interpolate remote movements on client for smoothness, though with 20 players and moderate rate, it might be okay to jump them to position).  

## Chat Functionality  
17. **Implement chat UI component** – Create a React component `<ChatPanel>` that renders a list of messages and an input box. Place it overlaying the game canvas (e.g. styled with CSS position absolute, bottom:0, left:0, width: maybe 30% of screen, height: 150px, overflow-y: scroll for messages). Style it simply. In React state, maintain an array of chat messages. Render each message as a `<div>` or `<p>`. Also create an input field; on submit (Enter key), call a handler to send the message. Integrate this component in the main page (e.g., include `<ChatPanel>` in the JSX so it shows up).  
18. **Send and receive chat messages** – On the client, when the user submits chat text, emit a `chat` event via WebSocket with the message text. Also optimistically add it to your own chat panel (or you can wait to add on echo from server). On the server, listen for `chat` events. When received, prepend the sender’s name (which you have from when they joined) and broadcast a `chat` (or `chatMessage`) event to all clients with `{name, text}`. On clients, listen for `chatMessage` and, when received, append it to the chat panel state (trigger re-render to show it). Ensure that the chat scrolls to the bottom on new message (you can do this via ref or by always rendering with newest at bottom and CSS auto-scroll). Test sending chat between two clients to ensure messages appear on both. Also handle clearing the input field after sending.  
19. **Name input (optional if needed)** – If you want players to set a username, implement a simple prompt on join. E.g., show a modal or prompt at game start asking for a name, then include that in the connection (perhaps send a `join` event to server with the name). The server then uses that name for broadcasts. If not, just assign default names like “Player123”. In RuneScape context, having a name is important for identity, so this is recommended even if trivial. Could also simply use the socket ID as name for now for testing.

## World and Resource Setup  
20. **Create world objects (trees, rocks, etc.)** – In the Three.js scene, add some meshes to represent resources: e.g., a few **tree** meshes in Lumbridge area. This could be a simple cylinder + sphere combo (cylinder trunk, sphere foliage) or any quick way to show a tree. Similarly add **rock** meshes in another area for mining, and maybe a **water plane** for a fishing spot. These objects should have unique identifiers so we know which one is interacted with. You can create a simple class or data structure for ResourceNode with properties like id, type (“tree”/“rock”/“fish”), position (x, y, z). Hardcode a handful of nodes: e.g., 3 trees near Lumbridge spawn, 2-3 rocks in Barbarian Village, and a fishing spot near a water area. Also consider adding a few non-interactive props for atmosphere (like a building or two, or a campfire). This step is mainly to set the stage for interaction. Make sure these objects are added to an array so we can iterate for interaction (for raycasting on click). They should be added to the Three.js scene for rendering.  
21. **Raycast for clicks on resources** – Implement click picking. In the Three.js canvas component, listen for `mousedown` or `click` events on the canvas. Use `THREE.Raycaster` to cast a ray from the camera through the mouse position into the scene. Check if it intersects any resource node mesh. If so, determine which resource was clicked (you can tag the mesh with a custom property linking to the resource id or have a mapping from mesh to resource data). If a tree or rock is clicked, initiate a gathering action. Possibly also check distance: ensure the player’s avatar is close enough to that resource; if not, you might ignore or maybe move the player there first (auto-walk could be too much, so probably just require manual proximity). For now, assume the user will move near and click.  
22. **Gather action request** – When a resource is clicked (and presumably in range), have the client emit a `gather` event to the server with the resource id (and type if needed, but id can imply type). Also, on the client, you can give immediate feedback: e.g., start a short timer or disable another click until server responds. Optionally, you could play an animation or change the resource appearance (e.g., tint the tree to indicate chopping). Those visual cues can be stretch enhancements; for now maybe just a console log “gathering...”.  
23. **Server-side gather logic** – On the server, handle the `gather` event. Upon receiving, find which resource it is. Check if it’s available (you might not have a complex state for resources; maybe keep a simple set of currently unavailable ones if we wanted a respawn system). Likely we won’t implement depletion, so it’s always available. Then determine the item to give: if resource type is tree -> item = “Log”, rock -> “Coal”, fish spot -> “Fish”. Create an entry for that item. Now update the player’s inventory on server side: add the item to their list. (If server was not tracking inventory, we should; let’s maintain a map of socket.id -> inventory array on server for authoritative tracking). Then emit an `inventoryUpdate` event to that specific client (so they know they got the item). Could also send a confirmation like `gatherSuccess` or simply piggyback on the inventory update. If we wanted others to see that action, we could broadcast something like “player X gathered resource Y”, but that’s not essential.  
24. **Client inventory update handling** – When the client receives `inventoryUpdate` (likely containing the full updated inventory or just the new item), update the React state for the inventory list. This will cause the InventoryPanel to re-render and show the new item. For simplicity, send the full inventory each time (which is small). Alternatively, send just the item delta and let client add it – either works. Confirm that when you click a resource in one client, that client’s inventory UI updates with the item. It should not yet reflect on other clients because each player’s inventory is separate. (We’re not showing other players’ inventories anywhere except possibly if we chat about it or drop items.)  
25. **Inventory panel and drop** – Create an `<InventoryPanel>` React component to display the inventory items (if not done earlier). It should iterate over inventory state and list items (with count if multiple). Next to each item, include a “Drop” button. Style the panel (e.g., top-right corner or a fixed small window). Ensure this panel updates on inventory state changes (React state handling).  

## Item Dropping and Picking  
26. **Drop item action** – Implement the drop functionality. When the player clicks “Drop” on an item in the InventoryPanel, trigger a handler that emits a `dropItem` event to the server with the item type (and maybe an item id or index if needed to distinguish multiple of same type—could assume one at a time drop for simplicity). Also include the player’s current position (the server could know it, but sending doesn’t hurt) so the drop spawns there. On the client side, also remove that item from the inventory state immediately (or wait for server confirm). Probably best to wait for server to confirm, to keep authoritative state.  
27. **Server drop handling** – On `dropItem` event (server), verify the player has that item in inventory (if tracking server-side). Remove one instance of it from their inventory list. Create a new world drop object with an id (generate a unique id or use a combination of item+timestamp), item type, and position (player’s position from data or server’s record). Add this to a server-side list of world items. Broadcast an `itemDropped` event to all clients with the drop’s details: `{ dropId, itemType, x, y, z }`.  
28. **Spawn dropped item in world** – On the client, listen for `itemDropped`. When received, create a visible object in the Three.js scene to represent the dropped item. It could be a small box or an icon sprite. Possibly use different colors or mini-models for different item types (e.g., brown box for log, gray for coal, blue for fish). Store these in a list of drop objects on the client, and perhaps also their id for reference. This way, everyone sees the item appear on ground. Also update the dropping player’s inventory UI via the earlier `inventoryUpdate` (the server should also send an inventory update to the dropper after removing the item, so they see it gone from their list – do this if not already done in drop handling).  
29. **Pick up item action** – Allow players to pick up dropped items. There are two ways: (a) clicking the item in the world (similar to resource click), or (b) auto-pickup by proximity. The easier to implement reliably is clicking (so we reuse raycasting). Implement raycast logic such that if the user clicks on a dropped item mesh, and is within a certain small radius of it (to prevent picking up across the map), then client emits a `pickup` event with the dropId. Alternatively or additionally, you can check distance on server for security. (Since we have positions, server can validate distance between player and item before giving item.)  
30. **Server pickup handling** – On `pickup` event, check if that dropId exists in world items list. If yes, and if the player is near it (optional check: compute distance between player position and item position, allow if < some threshold, say 5 units), then remove the item from world list and add the item to that player’s inventory. Broadcast an `itemRemoved` (with dropId) to all clients to despawn it, and send an `inventoryUpdate` to the picking player (with their new inventory). If the distance check fails or item doesn’t exist (maybe already picked), you might send a failure (or just ignore).  
31. **Client item removal** – On all clients, handle `itemRemoved` by finding the corresponding drop mesh in scene and removing it (and maybe disposing of it). On the picking client, also handle the `inventoryUpdate` that adds the item. Test this flow: one client drops an item, another client clicks it to pick up. The item should disappear from both clients’ views and appear in the second client’s inventory. The first client’s inventory should have had it removed when dropped.  

## Additional Features and Polish  
32. **Player name labels** – Add floating name labels above player avatars so players can identify each other. Implement by creating a HTML `<div>` or canvas 2D label for each player and update its screen position each frame according to the player’s 3D position (using camera projection). There are libraries or Three.js `CSS2DRenderer` that can simplify this. Alternatively, use a simple sprite or text in Three.js (but 3D text might always face camera using `Sprite`). Given time, a quick method is to use an extra canvas renderer for text. This is a nice-to-have UI improvement so players see “Alice” over one avatar, etc.  
33. **Zone indicators (optional)** – To make zones clear, you could add signage or change ground color between areas. For example, put a signpost reading “Wilderness” at the boundary and maybe draw a line. Or simply print the current zone name on screen (determine zone by player coords). This can be done client-side easily: each frame, check player position and set a text like “Location: Lumbridge” somewhere on UI.  
34. **Sound effects (optional)** – If assets are available or can be quickly generated, add simple sounds for events: e.g., chopping sound when woodcutting, a mining cling, a splash for fishing, and maybe a notification sound for chat or when another player joins. Integrating sound involves preloading audio files and playing them with the Web Audio API or HTML5 Audio on certain events. This is lower priority but adds feedback.  
35. **Testing and bug fixes** – Conduct multiplayer testing with multiple clients. Open several browser windows (or use an automated test if possible) to simulate ~3-5 players. Test scenarios: all players moving simultaneously (ensure positions update correctly and no one gets “stuck” or disappears), chat from various players (all receive and display), resource gathering (each player can independently gather and get items; two players gathering the same resource concurrently – with our infinite resource model this is fine, they both get items), item drop and pickup (make sure one player can’t pick up twice or a nonexistent item, ensure inventory counts are correct). Fix any issues discovered (e.g., if movement messages overwhelm, consider lowering frequency or if chat input focusing is an issue, adjust event propagation, etc.). Ensure the game remains stable if someone disconnects and rejoins.  
36. **Performance tuning (if needed)** – If the frame rate is low, consider optimizations: e.g., limit the number of Three.js objects (merge meshes for static environment if too many, or reduce render distance if we had a huge world). If network usage is high, make messages smaller (e.g., send compressed or less frequent updates). Given the small scope, likely fine. Also handle any memory leaks (make sure on client, when removing objects or on unmount, you dispose of Three.js geometries, etc., to not accumulate).  
37. **Deploy or run production build (optional)** – If time remains, prepare the app for deployment. This could mean running `next build` and ensuring the production version works the same. If hosting, note that Next.js on platforms like Vercel might not support long-running WebSocket in API routes easily (serverless issue). We might need a custom Node server to run the Socket.IO. For the 35-hour project, running locally or on a VM is fine. Document that limitation if deploying.  

## Stretch Goal Implementation (Optional)  
The following tasks are optional and should be done only after all core features above are complete and tested. They are likely to extend beyond the initial 35 hours or can be used to polish the game if core work finishes early.

- **(Optional) Implement PvP Combat in Wilderness** – Add a basic attack mechanism. For instance, allow clicking on another player’s avatar in the Wilderness to initiate attack. Server handles an `attack` event: reduce the target’s health (keep a health property in player state). Broadcast `playerHealth` update. If health ≤ 0, broadcast `playerDied`. On client, display health bars (could be a small red bar above players or in UI when targeted). If a player dies, perhaps remove them or respawn at Lumbridge (reset health, maybe drop their items as loot). This involves multiple steps: track health in server player objects, include health in `initPlayers` and updates, and create UI for it. Keep it very simple due to time.  
- **(Optional) Trading Interface** – Create a modal that opens when a player clicks “Trade” on another player (you’d need to add a UI element for that, perhaps by clicking their name label or a command). Implement a trade request/accept flow: one player sends `tradeRequest` to server with target id, server forwards to target. If target accepts (maybe they click an “Accept trade” button triggered by an event), then open a trade window on both sides. In the trade window, allow each to select items from their inventory to offer (maybe limit to 1 item each for simplicity). When both click Confirm, server swaps the items between inventories and sends updates. This is quite complex to do properly, so likely skip unless core done and significant time left.  
- **(Optional) Mobile Support** – Adjust CSS and controls for smaller screens. This could include adding a virtual joystick (there are libraries or one can make a draggable circle that updates an analog direction, which then maps to movement). Also ensure touch events can be used for camera (like dragging finger to rotate camera) and tapping for interactions. Test on a mobile device browser if possible. Also resize UI elements to be larger for touch.  
- **(Optional) Visual Improvements** – Swap out the simple shapes with better models if available. For example, use an actual tree model (perhaps a low-poly tree from a free asset library) and load via Three.js GLTFLoader. Use a character model for players (maybe a primitive humanoid or even a sphere for head and capsule for body). Add basic animations: e.g., when moving, play a “walking” animation or just bob the model. For woodcutting, you could animate the tree or the player (swing an axe animation if we had one). Add particle effects or sound for extra feedback. These things enrich the game but each can take significant time, so only attempt if ahead of schedule or for future development.  
- **(Optional) Persist Player Data** – Integrate a backend database (could be a simple file or an actual DB) to save player info (name, inventory, maybe position) so that if the server restarts or player reconnects, they resume where they left off. This would involve hooking into join/disconnect to load/save data. Perhaps use Next.js API routes or direct Node fs calls to store JSON. With limited time, this might be skipped, but it’s a logical next step after the prototype is stable.

By following the above checklist sequentially, we build the game in incremental layers—first the infrastructure (project, rendering, networking), then core gameplay features (movement, chat, gathering, inventory), and finally any additional enhancements. Each step is scoped such that an LLM agent or developer can implement and verify it before moving on, ensuring steady progress toward a fully functional multiplayer web RPG. With the core features implemented, we will have a small but complete RuneScape-inspired browser game, and we can then iteratively refine it or add the stretch features as time allows.